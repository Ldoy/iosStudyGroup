# 0627 클로저 도이

### sorted method

- 제공된 backward 라는 함수의 타입이 sorted의 sorting closure

```swift
let names = ["A", "B", "C", "D"]

func backward(_ s1: String, _ s2: String) -> Bool {

return s1 > s2

}

var reversedNames = names.sorted(by: backward(_:_:))
```

- 위의 `backward(_:_:)` 와 동일하게 작용. 클로져 자체를 인자로 받는 경우 parameter 정확히 명시 가능
- `in` 이라는 키워드의 의미 : 파라미터와 리턴타입이 끝났다. 클로저의 바디가 시작될 것이다 라는 의미

```swift
reversedNames = names.sorted(by: > )

//static func > (lhs: Self, rhs: Self) -> Bool

//reversedNames = names.filter { $0 < $1 } // 하나의 인자만 가능

reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2

})
```

- 왜 생략 가능할까?

    ⇒ argument로 클로저가 쓰이는경우 스위프트는 **타입을 추론할 수 있다**. `sorted`메소드의 경우 string의 array에서만 호출 하고 있다는 것을 clear하게 알 수 있기 때문에 function type인 (string, String) -> Bool 임을 알 수 있다. 따라서 s1, s2의 타입을 명시하지 않아도 됨.

- 추론 생략 안해도 좋지만(코드의 가독성을 위해서) 이 처럼 클로저의 사용이 명확한 경우엔 생략하는게 좋다.

```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 })
```

- s1 > s2을 포함하고 있기때문에 클로저는 반드지 Bool 타입을 리턴한다는 것을 알 수 있다. 따라서 return 생략해도 됨

```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2})
```

- 파라미터 이름도 생략

```swift
reversedNames =  names.sorted(by: { $0 > $1 })
```

### Trailing Closures

When you call this function to load a picture, you provide two closures. The first closure is a completion handler that displays a picture after a successful download. The second closure is an error handler that displays an error to the user.

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}

loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

- it’s guaranteed that number % 10 will always be a valid subscript key for the digitNames dictionary, and so an exclamation point is used to force-unwrap the String value stored in the subscript’s optional return value.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {

print("someFunctionThatTakesAClosure")

}

someFunctionThatTakesAClosure(closure: { })

someFunctionThatTakesAClosure() {

//trailing closure의 바디를 이곳에 쓰면 됨

}

let digitNames = [ 0: "Zero", 1: "One", 2: "Two", 3: "Three"]

let numbers = [10, 2, 3]

let strings = numbers.map { (number) -> String in

var varnumber = number

var output = ""

repeat {

output = digitNames[varnumber % 10]! + output

varnumber /= 10

} while varnumber > 0

return output

}

strings // 
```

### capturing values

// It does this by capturing a reference to runningTotal and amount from the surrounding function and using them within its own function body. Capturing by reference ensures that runningTotal and amount don’t disappear when the call to makeIncrementer ends, and also ensures that runningTotal is available the next time the incrementer function is called.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {

var runningTotal = 0

func incrementer() -> Int {

runningTotal += amount

return runningTotal

}

return incrementer

}
```

As an optimization, Swift may instead capture and store a copy of a value if that value isn’t mutated by a closure, and if the value isn’t mutated after the closure is created.

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)

incrementByTen()

incrementByTen()

var completionHandlers: [() -> Void] = []

func someFunctionWithEscapingClosure(completionsHandler: @escaping () -> Void) {

completionHandlers.append(completionsHandler)

}
```

Capturing self in an escaping closure makes it easy to accidentally create a strong reference cycle. For information about reference cycles, see Automatic Reference Counting.